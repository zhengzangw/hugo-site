---
title: 6-设计模式
date: 2020-03-14
weight: 6
---

## 设计模式简介

- 起源与建筑学：《A Pattern Language: Towns, Buildings, Construction》建筑的永恒之道，Christopher Alexander
- 模式：A Pattern Language: Towns, Buildings, Construction
  - Context：模式可适用的前提条件
  - Theme/Problem：在特定条件下要解决的目标问题
  - Solution：对目标问题求解过程中各种物理关系的记述
- 软件设计模式：《Design Patterns》Gang of Four
- 软件模式：软件开发的总体指导思路或参照样板
  - 在软件生存期的每一个阶段都存在着一些被认同的模式
  - 对软件开发这一特定“问题”的“解法”的某种统一表示
  - 软件模式等于一定条件下的出现的问题以及解法
  - Pattern name, Problem, Solution, Consequences
- 大三律(Rule of Three)：只有经过三个以上不同类型（或不同领域）的系统的校验，一个解决方案才能从候选模式升格为模式
- 设计模式分类
  - 目的
    - Creational: 创建对象
    - Structural: 处理类或对象的组合
    - Behavioral: 描述对类或对象怎样交互和怎样分配职责
  - 范围
    - 类模式：处理类和子类之间的关系，静态
    - 对象模式：处理对象间的关系，动态

## GoF 设计模式

![GoF Pattern](/images/content/GoF.png)

- Simple Factory (Static Factory Method): 根据参数的不同返回不同类的实例，专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类
  - 包含角色：工厂，抽象产品，具体产品
- Factory Method (Virtual Constructor/Polymorphic Factory): 工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类
  - 包含角色：抽象工厂，具体工厂，抽象产品，具体产品
- Abstract Factory (Kit)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类
  - 产品等级结构：产品等级结构即产品的继承结构
  - 产品等级结构：产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品
- Builder：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
  - 包含角色：抽象建造者，具体建造者，产品，指挥者
- 组合模式：组合多个对象形成树形结构以表示“整体-部分”的结构层次
  - 包含角色：抽象构件，叶子构件，容器构件，客户类
- Singleton：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例
  - 单例类的构造函数为私有；
  - 提供一个自身的静态私有成员变量；
  - 提供一个公有的静态工厂方法
- 观察者模式 (Publish/Subscribe, Model/View, Source/Listener, Dependents)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新
- 访问者模式：表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作

## 六大原则

- 单一职责原则(Single Responsibility Principle)：就一个类而言， 应该仅有一个引起它变化的原因。
  - 防止职责扩散
- 开放封闭原则（Open Close Principle）：类、模块、函数等应该是可以拓展的，但是不可修改。
- 里氏替换原则（Liskov Substitution Principle）：所有引用基类的地方必须能透明地使用其子类的对象。
  - 如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型
  - 类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法
- 依赖倒置原则（Dependence Inversion Principle）：高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。
- 接口隔离原则（InterfaceSegregation Principles）：一个类对另一个类的依赖应该建立在最小的接口上。
- 迪米特原则（Law of Demeter）也称最少知识原则：一个软件实体应当尽可能少地与其他实体发生相互作用。
  - 降低耦合，减少扇入扇出