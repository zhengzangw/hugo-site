---
title: 1-软件工程引论
date: 2020-03-01
weight: 1
---

## 软件问题历史

- 1996年6月4日因软件失效在发射40秒后爆炸，原因是惯性参考系统软件的数据转换异常造成的失效。
- 2004年12月20日，美空军第422测试评估大队的一架F-22战斗机因软件问题在起飞过程中失控坠毁。
- 2003年8月14日，美国北部电力丢失，原因是多计算机系统试图同时访问同一资源引起的软件失效
- 2004年9月14日，5 p.m. 美国400架飞机失去联络，原因是空管软件时钟缺陷
- 2005年11月1日，东京证券交易所因为软件升级出现系统故障，导致早间股市“停摆”
- 2002年NIST估计软件问题造成美国年经济损失约600亿美元，占GDP的0.6%
- 2007年5月17日和18日，诺顿杀毒软件导致全部安装了该软件的计算机系统瘫痪

## 软件危机

- 表现：成本高，软件质量得不到保证，进度难以控制，维护非常困难
- 根本原因
  - 逻辑产品
  - 复杂性高
  - 规模大
  - 缺乏有效、系统的原理、原则、方法和工具的指导与辅助
- 软件工程：为克服软件危机而提出的一种概念
  - 核心内容：按工程化的原则和方法组织软件开发工作
  - 主要任务：通过提供规范化的分析设计方法及工具软件，来避免或减少软件错误的发生，为最终根除软件危机提供强有利的技术保障
- 软件产品没有“质保”，没有“三包”
- 复杂系统的五个共同属性（Grady Booch） 
  - Hierarchic Structure
  - Relative Primitives
  - Separation of Concerns
  - Common Patterns
  - Stable Intermediate Forms

## 软件工程内容

软件需求
,软件设计
,软件建模
,软件体系结构
,设计模式
,软件构造
,软件测试
,软件维护
,软件配置管理
,软件工程管理
,软件过程
,软件工程工具与方法
,软件质量

## 软件工程目标

可修改性，有效性，可靠性，可理解性，可维护性，可重用性，可适应性，可移植性，可追踪性，可互相操作性

## 软件工程原则

- 抽象，信息隐藏，模块化，局部化，一致性，完整性，可验证性
- Davis 提出的软件工程原则
  1. 质量放在首位
  2. 高质量的软件是可能的
  3. 尽早向客户提供产品
  4. 在编写需求之前确定问题
  5. 评估可选设计方案
  6. 使用适当的过程模型
  7. 在不同阶段使用不同的语言
  8. 最小化智力差距
  9. 将技术置于工具之前
  10. 在使之更快之前，请确保其正确性
  11. 检查代码
  12. 好的管理比好的技术更重要
  13. 人是成功的关键
  14. 勿盲目跟风
  15. 承担责任
- Walker Royce的现代软件管理十大原则
  1. 基于架构优先的方法建立过程。
  2. 建立一个迭代过程，以通过此过程尽早解决风险。
  3. 强调基于组件的开发，以减少编码工作量。
  4. 应该建立变更管理来处理迭代过程。
  5. 增强迭代开发过程环境（称为双向工程），以通过自动化工具在多个制品上频繁地进行多次变更。
  6. 使用基于模型和计算机可处理的符号来进行设计。
  7. 建立质量控制和项目进度评估的客观过程，包括评估所有中间制品。
  8. 为能够更早地评估中间制品，使用基于演示的方法，将其转换为用户场景的可执行演示。
  9. 计划增量式发布多个版本，每个版本由一组使用场景组成，并在细节上逐步演化。
  10. 建立一个可配置的过程，因为没有一个过程适合所有的软件开发。

## 中间件

- 在操作系统层之上的计算抽象层，提升编程抽象层次
- 屏蔽了底层异构环境
- 三大中间件平台：CORBA, J2EE, .NET
- OMG(Object Management Group)
  - 以 UML 为核心颁布技术无关建模标准：MOF, XMI, CWM, MDA
  - MDA 思想：分离业务功能分析与设计和实现技术与平台之间紧耦合的关系，从而将技术与平台变化对系统的影响降低到最小程度
- MDA 抽象层次划分
  - PIM: Platform-Independent Model，描述系统设计层次
  - PSM: Platform-Specific Model
- MDA 软件开发生命周期

![MDA](/images/content/MDA.png)

## 历史

- 软件工程：方法学
- 程序设计语言：实现层
- 提高抽象层次角度
  - 以机器为中心
  - 以应用为中心
  - 以企业为中心
- 程序员角色分化

### 程序设计语言

- First-generation languages (1954-1958)
  - FORTRAN I 数学表达式
  - ALGOL 58 数学表达式
  - Flowmatic 数学表达式
  - IPL V 数学表达式
- Second-generation languages (1959-1961)
  - FORTRAN II 子程序、单独编译
  - ALGOL 60 块结构、数据类型
  - COBOL 数据描述、文件处理
  - Lisp 列表处理、指针、垃圾收集
- Third-generation languages (1962-1970)
  - PL/1 FORTRAN+ALGOL+COBOL
  - ALGOL 68: ALGOL 60 严格继承
  - Pascal: ALGOL 60 简单继承(71,Wirth,Program=Algorithm+Data Structure)
  - Simula 类、数据抽象（OOP 的起源）
  - 68年 Dijkstra goto considered harmful
- 断代 (1970-1980)
  - C
  - FORTRAN 77
- 面向对象 (1980-1990)
  - Smalltalk 80（第一个广泛使用的 OOPL）
  - C++ (84)
  - Ada83
  - Eiffel
- C++ 退出垄断(2005)：机器性能的提升是编程语言的选择开始转向“人”的因素（好用）
  - 使用脚本语言的性能损失对真实世界的程序来讲经常微不足道，因为真实世界的程序往往受I/O事件等待、网络延迟以及缓存列填充等限制，而非CPU的自身效率
- Emergence of frameworks (1990-2000)
  - Visual Basic: Windows GUI 开发
  - Java
  - Python
  - J2EE
  - .NET
  - Visual C#: .NET 架构下 Java 竞争者
  - Visual Basic: .NET 架构下 Visual Basic
- 动态脚本语言
  - Javascript
  - Python
  - Ruby
- 函数式编程
  - Scala
  - Go
  - Java 8